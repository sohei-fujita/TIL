## データしか持たないクラスは作成しない
そのデータに対してロジックを作成する場合、別のクラス、離れた箇所になりがち。
離れているとその存在を知らずにいたるところに同じようなロジックが実装されることになる。
仕様変更による修正漏れも生じやすくなる。
初期化しないと使い物にならないクラス、未初期化状態が発生しうるクラスになることがある。

## 変数を使いまわさない。
使い回すということは再代入するということである。
再代入は変数の用途が代わり、意味合いが命名規則と変わり読み手が混乱してしまうので避けるべき。

## 処理をベタ書きせず、意味のあるまとまりでメソッド化
全て一つのメソッド内で処理を書くと、どこからどこまでがなんの処理か分かりにくくなるので、まとまりでメソッド化する。

## クラスとロジック
強く関係するデータとロジックを同じクラスにまとめる

## クラス設計に関して

まず基本的な考え方として、クラス単体で正常に動作すること。(データクラスは作成しない)
必ずコンストラクタで初期化をし、かつ不正値を設定できないようにバリデーションをコンストラクタに実装する。
ex)価格は負の値を持ったりしないので、その場合Exceptionを投げるようにする。

処理の対象外となる条件をメソッドの先頭に定義する方法をガード節と呼ぶ。(アーリーリターンとかもこれ)
不要な要素を先頭で除外できるので、後続のロジックがシンプルになる。

インスタンス変数の再代入は理解を難しくするため、イミュータブルにした方がよい。
この場合は変更はできなくなるが、変更したい場合は変更値を持ったインスタンスを新たに生成する。
ローカル変数やメソッドの引数(引数指定した変数に再代入)なども同じ理由でイミュータブルにした方がよい。

クラス設計はインスタンス変数を不正状態に陥らせないように設計するべき。

## 型指定
int や stringという型はプリミティブ型という。
クラスを型として指定すると、同じintでの再代入を防ぎ、例外をスローすることができる。

不正状態から防護する完全コンストラクタ＋ロジックを高凝集している値オブジェクトがオブジェクト指向設計の基本形となる。

## インスタンス変数
インスタンス変数に関しても、使いまわすと意図せぬ代入が生じるので、インスタンスは個別に生成する。

## 副作用
主作用は関数が引数を受け取り、値を返すこと。
副作用は主作用以外に状態が変化すること。

finalなどで不変にして新しいインスタンスを作成するようにする。
基本的には不変を設定した方がよい。(Rustなんかは不変は)

## 不変状態にしない例
パフォーマンスに問題が生じるケース。不変にした場合、値を変更するにはインスタンスを生成しなければならないのでパフォーマンスに影響がでる場合がある。リソース制約の厳しい組み込みソフトウェアなど。
パフォーマンス以外だと、スコープが局所的なケース。